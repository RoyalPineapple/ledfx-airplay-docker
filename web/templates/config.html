<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirGlow - AirPlay Configuration</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="banner-container">
        <img src="https://raw.githubusercontent.com/RoyalPineapple/airglow/master/web/static/banner.jpg" alt="Aurora Borealis" class="banner-image" onerror="this.parentElement.style.display='none'">
        <div class="banner-overlay">
            <h1 class="banner-title">AirGlow</h1>
            <p class="banner-tagline">AirPlay Configuration</p>
        </div>
    </div>
    <div class="container">
        <header>
            <nav>
                <a href="/">Home</a>
                <a href="/status">Status Dashboard</a>
            </nav>
        </header>

        <div id="error-message" class="message error-message" role="alert" style="display: none;">
            <span id="error-text"></span>
            <button type="button" class="message-close" data-target="error-message" aria-label="Dismiss error">&times;</button>
        </div>
        <div id="success-message" class="message success-message" role="status" style="display: none;">
            <span id="success-text"></span>
            <button type="button" class="message-close" data-target="success-message" aria-label="Dismiss message">&times;</button>
        </div>
        <div id="save-status" class="save-status-bar" aria-live="polite">Ready to edit hooks.</div>

        <section class="config-section airplay-settings">
            <div class="airplay-header">
                <div>
                    <h2>AirPlay Device Name</h2>
                    <p class="section-description">Change how this receiver appears in the AirPlay menu. Restart Shairport-Sync after saving to apply the change.</p>
                </div>
            </div>
            <div class="airplay-name-form">
                <label for="airplay-name-input" class="airplay-name-label">AirPlay device name</label>
                <input type="text" id="airplay-name-input" class="airplay-name-input" maxlength="50" placeholder="Airglow">
                <p id="airplay-feedback" class="helper-text muted">Max 50 characters (Shairport-Sync limit).</p>
                <div class="airplay-button-row">
                    <button type="button" id="save-airplay-name-btn" class="btn btn-primary">Save Name</button>
                    <button type="button" id="restart-shairport-btn" class="btn btn-warning">Restart Shairport-Sync</button>
                </div>
                <p class="helper-text warning-text">Restarting will briefly interrupt any active AirPlay sessions.</p>
            </div>
        </section>

        <section id="no-devices-banner" class="config-section no-devices" style="display: none;">
            <h3>No LedFX Devices Detected</h3>
            <p>Add at least one device in LedFX before configuring AirPlay hooks. Once a device exists, reload this page.</p>
            <a href="#" id="open-ledfx-link" class="btn btn-outline" target="_blank" rel="noreferrer noopener">Open LedFX</a>
        </section>

        <section class="hook-summary-grid">
            <div class="hook-summary-card" id="start-summary-card">
                <h3>When AirPlay Connects</h3>
                <p class="summary-status" id="start-summary-status">Enabled</p>
                <p class="summary-details" id="start-summary-details">No actions configured yet.</p>
            </div>
            <div class="hook-summary-card" id="end-summary-card">
                <h3>When AirPlay Disconnects</h3>
                <p class="summary-status" id="end-summary-status">Enabled</p>
                <p class="summary-details" id="end-summary-details">No actions configured yet.</p>
            </div>
        </section>

        <form id="config-form">
            <!-- When AirPlay Connects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Connects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="start-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay connects</p>
                
                <fieldset id="start-hook-config" class="hook-config-section">
                    <!-- Mode Selector -->
                    <div class="mode-selector" role="group" aria-label="Start hook mode">
                        <label class="mode-option">
                            <input type="radio" name="start-mode" value="toggle" class="mode-radio" data-hook="start" checked>
                            <span class="mode-option-title">Toggle virtuals</span>
                            <span class="mode-option-description">Turn specific LedFX virtuals on when AirPlay connects.</span>
                        </label>
                        <label class="mode-option">
                            <input type="radio" name="start-mode" value="scene" class="mode-radio" data-hook="start">
                            <span class="mode-option-title">Trigger a scene</span>
                            <span class="mode-option-description">Activate a LedFX scene instead of toggling virtuals.</span>
                        </label>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="start-toggle-mode" class="mode-content">
                        <p class="list-helper">Choose which virtuals should turn on. Use repeats for devices that need the command sent multiple times (e.g., some Govee controllers).</p>
                        <div class="virtual-selection-controls" id="start-virtual-selection-controls" style="display: none;">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="start-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">Select all virtuals</span>
                            </label>
                        </div>

                        <div id="start-virtuals-list" class="virtuals-list">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="start-scene-mode" class="mode-content" style="display: none;">
                        <p class="list-helper">Pick one or more LedFX scenes to activate when AirPlay connects.</p>
                        <div id="start-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </fieldset>
            </section>

            <!-- When AirPlay Disconnects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Disconnects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="end-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay disconnects</p>
                
                <fieldset id="end-hook-config" class="hook-config-section">
                    <!-- Mode Selector -->
                    <div class="mode-selector" role="group" aria-label="End hook mode">
                        <label class="mode-option">
                            <input type="radio" name="end-mode" value="toggle" class="mode-radio" data-hook="end" checked>
                            <span class="mode-option-title">Toggle virtuals</span>
                            <span class="mode-option-description">Turn selected virtuals off when AirPlay disconnects.</span>
                        </label>
                        <label class="mode-option">
                            <input type="radio" name="end-mode" value="scene" class="mode-radio" data-hook="end">
                            <span class="mode-option-title">Trigger a scene</span>
                            <span class="mode-option-description">Switch to a LedFX scene when playback stops.</span>
                        </label>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="end-toggle-mode" class="mode-content">
                        <p class="list-helper">Choose which virtuals should turn off. Repeats can send multiple shutdown signals for stubborn devices.</p>
                        <div class="virtual-selection-controls" id="end-virtual-selection-controls" style="display: none;">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="end-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">Select all virtuals</span>
                            </label>
                        </div>

                        <div id="end-virtuals-list" class="virtuals-list">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="end-scene-mode" class="mode-content" style="display: none;">
                        <p class="list-helper">Pick LedFX scenes to activate when AirPlay disconnects.</p>
                        <div id="end-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </fieldset>
            </section>

        </form>
    </div>

    <script>
        let configData = null;
        let availableVirtuals = [];
        let availableScenes = [];
        let hasDevices = false;
        let currentAirplayName = '';
        let airplayRequestInFlight = false;
        const airplayNameInput = document.getElementById('airplay-name-input');
        const airplayFeedbackEl = document.getElementById('airplay-feedback');
        const saveAirplayNameBtn = document.getElementById('save-airplay-name-btn');
        const restartShairportBtn = document.getElementById('restart-shairport-btn');
        const noDevicesBanner = document.getElementById('no-devices-banner');
        const openLedfxLink = document.getElementById('open-ledfx-link');
        const configForm = document.getElementById('config-form');
        // Track previous state of each control for rollback on failure
        let controlStates = new Map();
        let saveInProgress = false;
        let lastSavedAt = null;
        const saveStatusEl = document.getElementById('save-status');

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function updateSaveStatus(message, type = 'info') {
            if (!saveStatusEl) return;
            saveStatusEl.textContent = message;
            saveStatusEl.classList.remove('success', 'error');
            if (type === 'success') {
                saveStatusEl.classList.add('success');
            } else if (type === 'error') {
                saveStatusEl.classList.add('error');
            }
        }

        // Show error message (stays until dismissed)
        function showError(message) {
            const errorEl = document.getElementById('error-message');
            const errorText = document.getElementById('error-text');
            if (errorText) {
                errorText.textContent = message;
            } else {
                errorEl.textContent = message;
            }
            errorEl.style.display = 'flex';
            updateSaveStatus(message, 'error');
        }

        function initMessageClosers() {
            document.querySelectorAll('.message-close').forEach(btn => {
                btn.addEventListener('click', () => {
                    const targetId = btn.dataset.target;
                    const targetEl = document.getElementById(targetId);
                    if (targetEl) {
                        targetEl.style.display = 'none';
                    }
                });
            });
        }

        // Show success message
        function showSuccess(message) {
            const successEl = document.getElementById('success-message');
            const successText = document.getElementById('success-text');
            if (successText) {
                successText.textContent = message;
            } else {
                successEl.textContent = message;
            }
            successEl.style.display = 'flex';
        }

        // Load configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) {
                    showError(data.error);
                    return;
                }

                configData = data;
                availableVirtuals = data.available_virtuals || [];
                availableScenes = data.available_scenes || [];
                hasDevices = data.has_devices !== false;
                if (airplayNameInput) {
                    currentAirplayName = typeof data.airplay_name === 'string' ? data.airplay_name : '';
                    airplayNameInput.value = currentAirplayName;
                }

                // Update hook toggles
                const startEnabled = data.hooks.start_hook_enabled !== false;
                const endEnabled = data.hooks.end_hook_enabled !== false;
                
                document.getElementById('start-hook-enabled').checked = startEnabled;
                document.getElementById('end-hook-enabled').checked = endEnabled;

                // Enable/disable hook configuration sections based on enabled state
                setHookDisabled('start', !startEnabled);
                setHookDisabled('end', !endEnabled);

                // Update configuration for each hook (only if enabled)
                updateHookConfig('start', data.virtuals.hooks?.start);
                updateHookConfig('end', data.virtuals.hooks?.end);

                updateHookSummary('start', data.virtuals.hooks?.start, startEnabled);
                updateHookSummary('end', data.virtuals.hooks?.end, endEnabled);

                // Store initial state of all controls for rollback
                storeControlStates();

                updateSaveStatus('Configuration loaded. Changes auto-save.');

            } catch (error) {
                showError(`Failed to load configuration: ${error.message}`);
            }
        }

        // Update hook configuration UI (mode, virtuals, scenes)
        function updateHookConfig(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, mode: 'toggle', virtuals: [], all_virtuals: true, scenes: [] };
            }

            const mode = hookConfig.mode || 'toggle';

            document.querySelectorAll(`input[name="${hookType}-mode"]`).forEach(radio => {
                radio.checked = radio.value === mode;
            });
            
            // Show/hide mode content
            const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
            const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
            toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
            sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';

            // Hide "All Virtuals" checkbox when mode is scene
            const allVirtualsLabel = document.querySelector(`#${hookType}-all-virtuals`).closest('.all-virtuals-label');
            if (allVirtualsLabel) {
                allVirtualsLabel.style.display = mode === 'toggle' ? 'flex' : 'none';
            }

            if (mode === 'toggle') {
                updateVirtualSelection(hookType, hookConfig);
            } else {
                updateSceneSelection(hookType, hookConfig);
            }
        }

        function setHookDisabled(hookType, disabled) {
            const fieldset = document.getElementById(`${hookType}-hook-config`);
            if (fieldset) {
                fieldset.disabled = disabled;
            }
        }

        function updateHookSummary(hookType, hookConfig, enabled) {
            const statusEl = document.getElementById(`${hookType}-summary-status`);
            const detailsEl = document.getElementById(`${hookType}-summary-details`);
            if (!statusEl || !detailsEl) return;
            statusEl.textContent = enabled ? 'Enabled' : 'Disabled';
            detailsEl.textContent = enabled ? summarizeAction(hookConfig) : 'No actions will run.';
        }

        function summarizeAction(hookConfig) {
            if (!hookConfig) return 'Select an action to run.';
            const mode = hookConfig.mode || 'toggle';
            if (mode === 'scene') {
                const scenes = hookConfig.scenes || [];
                if (scenes.length === 0) return 'Select scenes to trigger.';
                if (scenes.length === 1) return `Trigger scene ${scenes[0]}.`;
                return `Trigger ${scenes.length} scenes.`;
            }
            if (hookConfig.all_virtuals) {
                return 'Toggle all virtuals.';
            }
            const count = (hookConfig.virtuals || []).length;
            if (count === 0) return 'Select virtuals to toggle.';
            return `Toggle ${count} virtual${count === 1 ? '' : 's'}.`;
        }

        // Update virtual selection UI for a hook
        function updateVirtualSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, virtuals: [], all_virtuals: true };
            }

            const allVirtualsChecked = hookConfig.all_virtuals === true;
            const selectedVirtuals = hookConfig.virtuals || [];
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            const allVirtualsCheckbox = document.getElementById(`${hookType}-all-virtuals`);

            // Update "All Virtuals" checkbox
            allVirtualsCheckbox.checked = allVirtualsChecked;

            // Hide entire virtual selection controls section if no virtuals are available OR no devices are configured
            const virtualSelectionControls = document.getElementById(`${hookType}-virtual-selection-controls`);
            if (virtualSelectionControls) {
                const shouldShow = hasDevices && availableVirtuals.length > 0;
                virtualSelectionControls.style.display = shouldShow ? 'block' : 'none';
            }
            
            // If no virtuals or no devices, force all_virtuals to false
            if ((!hasDevices || availableVirtuals.length === 0) && allVirtualsChecked) {
                allVirtualsCheckbox.checked = false;
                hookConfig.all_virtuals = false;
            }
            
            // Always show the virtuals list area and build it
            listEl.style.display = 'block';
            
            // Always build the list to show proper messages (no devices, no virtuals, or virtual list)
            buildVirtualsList(hookType, selectedVirtuals);
            
            // If "All Virtuals" is checked, check all individual virtual checkboxes
            if (allVirtualsChecked && hasDevices && availableVirtuals.length > 0) {
                document.querySelectorAll(`.virtual-checkbox[data-hook="${hookType}"]`).forEach(cb => {
                    cb.checked = true;
                });
            }
        }

        // Update scene selection UI for a hook
        function updateSceneSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { scenes: [] };
            }

            const selectedScenes = hookConfig.scenes || [];
            buildScenesList(hookType, selectedScenes);
        }

        // Build scenes list HTML
        function buildScenesList(hookType, selectedScenes) {
            const listEl = document.getElementById(`${hookType}-scenes-list`);
            listEl.innerHTML = '';

            if (availableScenes.length === 0) {
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Scenes';
                listEl.innerHTML = `<p class="no-virtuals">No scenes available yet. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create scenes, then reload this page.</p>`;
                return;
            }

            availableScenes.forEach(sid => {
                const sceneDiv = document.createElement('div');
                sceneDiv.className = 'scene-item';
                sceneDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="scene-checkbox" data-sid="${escapeHtml(sid)}" data-hook="${hookType}" ${selectedScenes.includes(sid) ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(sid)}</span>
                    </label>
                `;
                listEl.appendChild(sceneDiv);
            });
        }

        function initAirplayControls() {
            if (saveAirplayNameBtn) {
                saveAirplayNameBtn.addEventListener('click', handleAirplayNameSave);
            }
            if (restartShairportBtn) {
                restartShairportBtn.addEventListener('click', handleShairportRestart);
            }
        }

        async function handleAirplayNameSave() {
            if (!airplayNameInput || airplayRequestInFlight) return;
            const newName = airplayNameInput.value.trim();
            if (newName.length === 0) {
                showError('AirPlay name cannot be empty.');
                return;
            }
            if (newName.length > 50) {
                showError('AirPlay name must be 50 characters or fewer (Shairport-Sync limit).');
                return;
            }
            if (newName === currentAirplayName) {
                updateSaveStatus('AirPlay name is already set to that value.');
                return;
            }

            airplayRequestInFlight = true;
            saveAirplayNameBtn.disabled = true;
            updateSaveStatus('Saving AirPlay name...');

            try {
                const response = await fetch('/api/airplay-name', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ name: newName })
                });
                const result = await response.json().catch(() => ({}));
                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Failed to update AirPlay name.');
                }
                currentAirplayName = result.name || newName;
                showSuccess('AirPlay name saved. Restart Shairport-Sync to apply changes.');
                updateSaveStatus('AirPlay name saved. Restart to apply.', 'success');
            } catch (error) {
                showError(error.message || 'Failed to update AirPlay name.');
            } finally {
                airplayRequestInFlight = false;
                saveAirplayNameBtn.disabled = false;
            }
        }

        async function handleShairportRestart() {
            if (airplayRequestInFlight) return;
            if (!restartShairportBtn) return;
            const confirmed = window.confirm('Restarting Shairport-Sync will interrupt any active AirPlay sessions. Continue?');
            if (!confirmed) {
                return;
            }

            restartShairportBtn.disabled = true;
            updateSaveStatus('Restarting Shairport-Sync...');

            try {
                const response = await fetch('/api/shairport/restart', { method: 'POST' });
                const result = await response.json().catch(() => ({}));
                if (!response.ok || result.error) {
                    throw new Error(result.error || 'Failed to restart shairport-sync.');
                }
                showSuccess('Shairport-Sync restart triggered. Give it a few seconds to come back online.');
                updateSaveStatus('Shairport-Sync restarted.', 'success');
            } catch (error) {
                showError(error.message || 'Failed to restart shairport-sync.');
            } finally {
                restartShairportBtn.disabled = false;
            }
        }

        // Build virtuals list HTML
        function buildVirtualsList(hookType, selectedVirtuals) {
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            listEl.innerHTML = '';

            // Check for devices first (primary check)
            if (!hasDevices) {
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Devices';
                listEl.innerHTML = `<p class="no-virtuals">No LedFX devices configured. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to add devices, then reload this page.</p>`;
                return;
            }

            if (availableVirtuals.length === 0) {
                // Get LedFX URL from window location (same host, different port)
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Virtuals';
                listEl.innerHTML = `<p class="no-virtuals">No virtuals available. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create them, then reload this page.</p>`;
                return;
            }

            availableVirtuals.forEach(vid => {
                const virtualConfig = selectedVirtuals.find(v => v.id === vid) || { id: vid, repeats: 1 };
                const isSelected = selectedVirtuals.some(v => v.id === vid);
                const virtualDiv = document.createElement('div');
                virtualDiv.className = `virtual-item${isSelected ? ' active' : ''}`;
                virtualDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="virtual-checkbox" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" ${isSelected ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(vid)}</span>
                    </label>
                    <div class="virtual-repeats">
                        <div class="repeat-group">
                            <label>Repeats:</label>
                            <input type="number" class="repeat-input" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" value="${virtualConfig.repeats || 1}" min="0" max="10">
                        </div>
                    </div>
                `;
                listEl.appendChild(virtualDiv);
            });
        }


        // Store the current state of all controls for rollback
        function storeControlStates() {
            controlStates.clear();
            
            // Store hook toggles
            controlStates.set('start-hook-enabled', document.getElementById('start-hook-enabled').checked);
            controlStates.set('end-hook-enabled', document.getElementById('end-hook-enabled').checked);
            
            // Store mode tabs
            const startModeSelection = document.querySelector('input[name="start-mode"]:checked');
            const endModeSelection = document.querySelector('input[name="end-mode"]:checked');
            controlStates.set('start-mode', startModeSelection ? startModeSelection.value : 'toggle');
            controlStates.set('end-mode', endModeSelection ? endModeSelection.value : 'toggle');
            
            // Store all virtuals checkboxes
            controlStates.set('start-all-virtuals', document.getElementById('start-all-virtuals').checked);
            controlStates.set('end-all-virtuals', document.getElementById('end-all-virtuals').checked);
            
            // Store virtual checkboxes
            document.querySelectorAll('.virtual-checkbox').forEach(cb => {
                controlStates.set(cb.id || `virtual-${cb.dataset.hook}-${cb.dataset.vid}`, cb.checked);
            });
            
            // Store scene checkboxes
            document.querySelectorAll('.scene-checkbox').forEach(cb => {
                controlStates.set(cb.id || `scene-${cb.dataset.hook}-${cb.dataset.sid}`, cb.checked);
            });
            
            // Store repeat inputs
            document.querySelectorAll('.repeat-input').forEach(input => {
                controlStates.set(input.id || `repeat-${input.dataset.hook}-${input.dataset.vid}`, input.value);
            });
        }
        
        // Revert a specific control to its previous state
        function revertControl(controlId, previousValue) {
            const element = document.getElementById(controlId);
            if (!element) {
                // Try to find by data attributes
                const [type, hook, id] = controlId.split('-');
                if (type === 'virtual') {
                    const cb = document.querySelector(`.virtual-checkbox[data-hook="${hook}"][data-vid="${id}"]`);
                    if (cb) cb.checked = previousValue;
                } else if (type === 'scene') {
                    const cb = document.querySelector(`.scene-checkbox[data-hook="${hook}"][data-sid="${id}"]`);
                    if (cb) cb.checked = previousValue;
                } else if (type === 'repeat') {
                    const input = document.querySelector(`.repeat-input[data-hook="${hook}"][data-vid="${id}"]`);
                    if (input) input.value = previousValue;
                } else if (type === 'start' || type === 'end') {
                    const radio = document.querySelector(`input[name="${type}-mode"][value="${previousValue}"]`);
                    if (radio) radio.checked = true;
                    const toggleModeEl = document.getElementById(`${type}-toggle-mode`);
                    const sceneModeEl = document.getElementById(`${type}-scene-mode`);
                    if (toggleModeEl && sceneModeEl) {
                        toggleModeEl.style.display = previousValue === 'toggle' ? 'block' : 'none';
                        sceneModeEl.style.display = previousValue === 'scene' ? 'block' : 'none';
                    }
                }
                return;
            }
            
            if (element.type === 'checkbox') {
                element.checked = previousValue;
            } else if (element.type === 'number' || element.type === 'text') {
                element.value = previousValue;
            }
        }
        
        // Auto-save configuration on change
        async function autoSave(controlId, previousValue) {
            if (saveInProgress) {
                // If a save is already in progress, queue this one
                setTimeout(() => autoSave(controlId, previousValue), 100);
                return;
            }
            
            saveInProgress = true;
            
            try {
                // Collect current configuration
                const startEnabled = document.getElementById('start-hook-enabled').checked;
                const activeStartMode = document.querySelector('input[name="start-mode"]:checked');
                let startMode = activeStartMode ? activeStartMode.value : 'toggle';
                let startAllVirtuals = true;
                let startVirtuals = [];
                let startScenes = [];
                if (startEnabled) {
                    if (startMode === 'toggle') {
                        // Check if all virtuals are selected
                        const checkedBoxes = document.querySelectorAll('.virtual-checkbox[data-hook="start"]:checked');
                        if (hasDevices && availableVirtuals.length > 0 && checkedBoxes.length === availableVirtuals.length) {
                            // All virtuals are selected - use all_virtuals flag
                            startAllVirtuals = true;
                            startVirtuals = [];
                        } else {
                            // Some or no virtuals selected - collect individual selections
                            startAllVirtuals = false;
                            checkedBoxes.forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="start"][data-vid="${vid}"]`)?.value) || 1;
                                if (repeats > 0) {
                                    startVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.scene-checkbox[data-hook="start"]:checked').forEach(cb => {
                            startScenes.push(cb.dataset.sid);
                        });
                    }
                }

                const endEnabled = document.getElementById('end-hook-enabled').checked;
                const activeEndMode = document.querySelector('input[name="end-mode"]:checked');
                let endMode = activeEndMode ? activeEndMode.value : 'toggle';
                let endAllVirtuals = true;
                let endVirtuals = [];
                let endScenes = [];
                if (endEnabled) {
                    if (endMode === 'toggle') {
                        // Check if all virtuals are selected
                        const checkedBoxes = document.querySelectorAll('.virtual-checkbox[data-hook="end"]:checked');
                        if (hasDevices && availableVirtuals.length > 0 && checkedBoxes.length === availableVirtuals.length) {
                            // All virtuals are selected - use all_virtuals flag
                            endAllVirtuals = true;
                            endVirtuals = [];
                        } else {
                            // Some or no virtuals selected - collect individual selections
                            endAllVirtuals = false;
                            checkedBoxes.forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="end"][data-vid="${vid}"]`)?.value) || 0;
                                if (repeats > 0) {
                                    endVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.scene-checkbox[data-hook="end"]:checked').forEach(cb => {
                            endScenes.push(cb.dataset.sid);
                        });
                    }
                }

                const configPayload = {
                    start_enabled: startEnabled,
                    end_enabled: endEnabled,
                    start_hook: {
                        mode: startMode,
                        all_virtuals: startAllVirtuals,
                        virtuals: startVirtuals,
                        scenes: startScenes
                    },
                    end_hook: {
                        mode: endMode,
                        all_virtuals: endAllVirtuals,
                        virtuals: endVirtuals,
                        scenes: endScenes
                    }
                };

                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configPayload)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Failed to save configuration' }));
                    throw new Error(errorData.error || 'Failed to save configuration');
                }

                const data = await response.json();
                
                configData = configData || {};
                configData.hooks = {
                    start_hook_enabled: startEnabled,
                    end_hook_enabled: endEnabled
                };
                configData.virtuals = configData.virtuals || {};
                configData.virtuals.hooks = configData.virtuals.hooks || {};
                configData.virtuals.hooks.start = configPayload.start_hook;
                configData.virtuals.hooks.end = configPayload.end_hook;

                updateHookSummary('start', configPayload.start_hook, startEnabled);
                updateHookSummary('end', configPayload.end_hook, endEnabled);
                
                // Update stored states on success
                storeControlStates();
                
                // Show brief success indicator
                showControlFeedback(controlId, true);

                lastSavedAt = new Date();
                const timeStr = lastSavedAt.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' });
                updateSaveStatus(`Last saved at ${timeStr}`, 'success');
                
            } catch (error) {
                // Revert the control that failed
                revertControl(controlId, previousValue);
                showControlFeedback(controlId, false, error.message);
                showError(error.message);
            } finally {
                saveInProgress = false;
            }
        }
        
        // Show feedback for a specific control
        function showControlFeedback(controlId, success, errorMessage = null) {
            const element = document.getElementById(controlId);
            if (!element) return;
            
            // Remove existing feedback
            const existingFeedback = element.parentElement.querySelector('.control-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
            
            if (success) {
                const feedback = document.createElement('span');
                feedback.className = 'control-feedback success';
                feedback.textContent = '✓';
                feedback.title = 'Saved';
                element.parentElement.style.position = 'relative';
                element.parentElement.appendChild(feedback);
                setTimeout(() => feedback.remove(), 2000);
            } else {
                const feedback = document.createElement('span');
                feedback.className = 'control-feedback error';
                feedback.textContent = '✗';
                feedback.title = errorMessage || 'Failed to save';
                element.parentElement.style.position = 'relative';
                element.parentElement.appendChild(feedback);
                setTimeout(() => feedback.remove(), 3000);
            }
        }

        // Add change listeners to all form inputs with auto-save
        function addFormChangeListeners() {
            // Hook enable/disable toggles
            document.getElementById('start-hook-enabled').addEventListener('change', function() {
                const previousValue = controlStates.get('start-hook-enabled') || false;
                controlStates.set('start-hook-enabled', this.checked);
                setHookDisabled('start', !this.checked);
                if (configData) {
                    configData.hooks = configData.hooks || {};
                    configData.hooks.start_hook_enabled = this.checked;
                    updateHookSummary('start', configData.virtuals?.hooks?.start, this.checked);
                }
                autoSave('start-hook-enabled', previousValue);
            });

            document.getElementById('end-hook-enabled').addEventListener('change', function() {
                const previousValue = controlStates.get('end-hook-enabled') || false;
                controlStates.set('end-hook-enabled', this.checked);
                setHookDisabled('end', !this.checked);
                if (configData) {
                    configData.hooks = configData.hooks || {};
                    configData.hooks.end_hook_enabled = this.checked;
                    updateHookSummary('end', configData.virtuals?.hooks?.end, this.checked);
                }
                autoSave('end-hook-enabled', previousValue);
            });
            
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const hookType = this.dataset.hook;
                    const mode = this.dataset.mode;
                    const previousMode = controlStates.get(`${hookType}-mode`) || 'toggle';
                    
                    // Update active tab
                    document.querySelectorAll(`.mode-tab[data-hook="${hookType}"]`).forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Show/hide mode content
                    const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
                    const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
                    toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
                    sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';
                    
                    // Hide/show virtual selection controls based on mode AND device/virtual availability
                    const virtualSelectionControls = document.getElementById(`${hookType}-virtual-selection-controls`);
                    if (virtualSelectionControls) {
                        // Only show if toggle mode AND devices exist AND virtuals exist
                        const shouldShow = mode === 'toggle' && hasDevices && availableVirtuals.length > 0;
                        virtualSelectionControls.style.display = shouldShow ? 'block' : 'none';
                    }
                    
                    // If switching to toggle mode, update virtual selection to show proper messages
                    if (mode === 'toggle') {
                        const hookConfig = configData?.virtuals?.hooks?.[hookType] || { virtuals: [], all_virtuals: false };
                        updateVirtualSelection(hookType, hookConfig);
                    }
                    
                    // Build scenes list if switching to scene mode and list hasn't been built yet
                    if (mode === 'scene') {
                        const scenesListEl = document.getElementById(`${hookType}-scenes-list`);
                        if (scenesListEl.innerHTML.includes('Loading')) {
                            const hookConfig = configData?.virtuals?.hooks?.[hookType] || { scenes: [] };
                            updateSceneSelection(hookType, hookConfig);
                        }
                    }
                    
                    controlStates.set(`${hookType}-mode`, mode);
                    autoSave(`${hookType}-mode`, previousMode);
                });
            });
            
            // All virtuals checkboxes - act as "select all"
            document.getElementById('start-all-virtuals').addEventListener('change', function() {
                const previousValue = controlStates.get('start-all-virtuals') || false;
                controlStates.set('start-all-virtuals', this.checked);
                
                // Check/uncheck all individual virtual checkboxes
                document.querySelectorAll('.virtual-checkbox[data-hook="start"]').forEach(cb => {
                    cb.checked = this.checked;
                    const container = cb.closest('.virtual-item');
                    if (container) container.classList.toggle('active', cb.checked);
                    const id = cb.dataset.vid;
                    controlStates.set(`virtual-start-${id}`, cb.checked);
                });
                
                autoSave('start-all-virtuals', previousValue);
            });

            document.getElementById('end-all-virtuals').addEventListener('change', function() {
                const previousValue = controlStates.get('end-all-virtuals') || false;
                controlStates.set('end-all-virtuals', this.checked);
                
                // Check/uncheck all individual virtual checkboxes
                document.querySelectorAll('.virtual-checkbox[data-hook="end"]').forEach(cb => {
                    cb.checked = this.checked;
                    const container = cb.closest('.virtual-item');
                    if (container) container.classList.toggle('active', cb.checked);
                    const id = cb.dataset.vid;
                    controlStates.set(`virtual-end-${id}`, cb.checked);
                });
                
                autoSave('end-all-virtuals', previousValue);
            });

            document.querySelectorAll('.mode-radio').forEach(radio => {
                radio.addEventListener('change', function() {
                    if (!this.checked) return;
                    const hookType = this.dataset.hook;
                    const previousMode = controlStates.get(`${hookType}-mode`) || 'toggle';
                    controlStates.set(`${hookType}-mode`, this.value);

                    const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
                    const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
                    if (toggleModeEl && sceneModeEl) {
                        toggleModeEl.style.display = this.value === 'toggle' ? 'block' : 'none';
                        sceneModeEl.style.display = this.value === 'scene' ? 'block' : 'none';
                    }

                    const virtualSelectionControls = document.getElementById(`${hookType}-virtual-selection-controls`);
                    if (virtualSelectionControls) {
                        const shouldShow = this.value === 'toggle' && hasDevices && availableVirtuals.length > 0;
                        virtualSelectionControls.style.display = shouldShow ? 'block' : 'none';
                    }

                    if (this.value === 'toggle') {
                        const hookConfig = configData?.virtuals?.hooks?.[hookType] || { virtuals: [], all_virtuals: false };
                        updateVirtualSelection(hookType, hookConfig);
                    } else {
                        const hookConfig = configData?.virtuals?.hooks?.[hookType] || { scenes: [] };
                        updateSceneSelection(hookType, hookConfig);
                    }

                    autoSave(`${hookType}-mode`, previousMode);
                });
            });
            
            // Update "All Virtuals" checkbox when individual checkboxes change
            function updateAllVirtualsCheckbox(hookType) {
                if (!hasDevices || availableVirtuals.length === 0) return;
                
                const allCheckbox = document.getElementById(`${hookType}-all-virtuals`);
                const allCheckboxes = document.querySelectorAll(`.virtual-checkbox[data-hook="${hookType}"]`);
                const checkedCount = document.querySelectorAll(`.virtual-checkbox[data-hook="${hookType}"]:checked`).length;
                
                // Update "All Virtuals" checkbox based on individual selections
                if (allCheckboxes.length > 0) {
                    allCheckbox.checked = checkedCount === allCheckboxes.length;
                    controlStates.set(`${hookType}-all-virtuals`, allCheckbox.checked);
                }
            }
            
            // Listen for changes on checkboxes and inputs
            document.addEventListener('change', function(e) {
                if (e.target.matches('.virtual-checkbox, .scene-checkbox')) {
                    const hook = e.target.dataset.hook;
                    const identifier = e.target.dataset.vid || e.target.dataset.sid || '';
                    const typePrefix = e.target.classList.contains('virtual-checkbox') ? 'virtual' : 'scene';
                    const controlId = e.target.id || `${typePrefix}-${hook}-${identifier}`;
                    const previousValue = controlStates.get(controlId) || false;
                    controlStates.set(controlId, e.target.checked);
                    
                    // Update "All Virtuals" checkbox when individual virtual checkbox changes
                    if (e.target.matches('.virtual-checkbox')) {
                        const container = e.target.closest('.virtual-item');
                        if (container) {
                            container.classList.toggle('active', e.target.checked);
                        }
                        updateAllVirtualsCheckbox(hook);
                    }
                    
                    autoSave(controlId, previousValue);
                }
            });

            // Listen for input changes on repeat inputs (with debounce)
            let repeatInputTimeout = null;
            document.addEventListener('input', function(e) {
                if (e.target.matches('.repeat-input')) {
                    const controlId = e.target.id || `repeat-${e.target.dataset.hook}-${e.target.dataset.vid}`;
                    const previousValue = controlStates.get(controlId) || e.target.value;
                    
                    // Debounce repeat input saves (wait 500ms after user stops typing)
                    clearTimeout(repeatInputTimeout);
                    repeatInputTimeout = setTimeout(() => {
                        controlStates.set(controlId, e.target.value);
                        autoSave(controlId, previousValue);
                    }, 500);
                }
            });
        }

        // Initial load
        loadConfig();

        // Add form change listeners
        addFormChangeListeners();
        initMessageClosers();
        initAirplayControls();
        updateSaveStatus('Ready to edit hooks.');
    </script>
</body>
</html>
