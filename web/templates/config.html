<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirGlow Configuration</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="banner-container">
        <img src="https://raw.githubusercontent.com/RoyalPineapple/airglow/master/web/static/banner.jpg" alt="Aurora Borealis" class="banner-image" onerror="this.parentElement.style.display='none'">
        <div class="banner-overlay">
            <h1 class="banner-title">AirGlow Configuration</h1>
        </div>
    </div>
    <div class="container">
        <header>
            <nav>
                <a href="/">Home</a>
                <a href="/status">Status Dashboard</a>
            </nav>
        </header>

        <div id="error-message" class="error-message" style="display: none;"></div>
        <div id="success-message" class="success-message" style="display: none;"></div>

        <form id="config-form">
            <!-- When AirPlay Connects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Connects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="start-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay connects</p>
                
                <div id="start-hook-config" class="hook-config-section" style="display: none;">
                    <!-- Mode Tabs -->
                    <div class="mode-tabs">
                        <button type="button" class="mode-tab active" data-hook="start" data-mode="toggle">Toggle On</button>
                        <button type="button" class="mode-tab" data-hook="start" data-mode="scene">Scene</button>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="start-toggle-mode" class="mode-content">
                        <div class="virtual-selection-controls">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="start-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">All Virtuals</span>
                            </label>
                        </div>

                        <div id="start-virtuals-list" class="virtuals-list" style="display: none;">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="start-scene-mode" class="mode-content" style="display: none;">
                        <div id="start-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- When AirPlay Disconnects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Disconnects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="end-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay disconnects</p>
                
                <div id="end-hook-config" class="hook-config-section" style="display: none;">
                    <!-- Mode Tabs -->
                    <div class="mode-tabs">
                        <button type="button" class="mode-tab active" data-hook="end" data-mode="toggle">Toggle Off</button>
                        <button type="button" class="mode-tab" data-hook="end" data-mode="scene">Scene</button>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="end-toggle-mode" class="mode-content">
                        <div class="virtual-selection-controls">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="end-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">All Virtuals</span>
                            </label>
                        </div>

                        <div id="end-virtuals-list" class="virtuals-list" style="display: none;">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="end-scene-mode" class="mode-content" style="display: none;">
                        <div id="end-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- Save Button -->
            <div class="form-actions">
                <button type="submit" id="save-btn" class="btn btn-primary">Save Configuration</button>
                <span id="save-status" class="save-status"></span>
            </div>
        </form>
    </div>

    <script>
        let configData = null;
        let availableVirtuals = [];
        let availableScenes = [];
        let refreshInterval = null;
        let hasUnsavedChanges = false;
        let savedFormState = null;

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('error-message');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        // Show success message
        function showSuccess(message) {
            const successEl = document.getElementById('success-message');
            successEl.textContent = message;
            successEl.style.display = 'block';
            setTimeout(() => {
                successEl.style.display = 'none';
            }, 3000);
        }

        // Load configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) {
                    showError(data.error);
                    return;
                }

                configData = data;
                availableVirtuals = data.available_virtuals || [];
                availableScenes = data.available_scenes || [];

                // Update hook toggles
                const startEnabled = data.hooks.start_hook_enabled !== false;
                const endEnabled = data.hooks.end_hook_enabled !== false;
                
                document.getElementById('start-hook-enabled').checked = startEnabled;
                document.getElementById('end-hook-enabled').checked = endEnabled;

                // Show/hide hook configuration sections based on enabled state
                document.getElementById('start-hook-config').style.display = startEnabled ? 'block' : 'none';
                document.getElementById('end-hook-config').style.display = endEnabled ? 'block' : 'none';

                // Update configuration for each hook (only if enabled)
                if (startEnabled) {
                    updateHookConfig('start', data.virtuals.hooks?.start);
                }
                if (endEnabled) {
                    updateHookConfig('end', data.virtuals.hooks?.end);
                }

                // Save the current form state as the "saved" state
                savedFormState = getFormState();
                hasUnsavedChanges = false;

            } catch (error) {
                showError(`Failed to load configuration: ${error.message}`);
            }
        }

        // Update hook configuration UI (mode, virtuals, scenes)
        function updateHookConfig(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, mode: 'toggle', virtuals: [], all_virtuals: true, scenes: [] };
            }

            const mode = hookConfig.mode || 'toggle';
            
            // Update mode tabs
            document.querySelectorAll(`.mode-tab[data-hook="${hookType}"]`).forEach(tab => {
                if (tab.dataset.mode === mode) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Show/hide mode content
            const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
            const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
            toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
            sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';

            // Hide "All Virtuals" checkbox when mode is scene
            const allVirtualsLabel = document.querySelector(`#${hookType}-all-virtuals`).closest('.all-virtuals-label');
            if (allVirtualsLabel) {
                allVirtualsLabel.style.display = mode === 'toggle' ? 'flex' : 'none';
            }

            if (mode === 'toggle') {
                updateVirtualSelection(hookType, hookConfig);
            } else {
                updateSceneSelection(hookType, hookConfig);
            }
        }

        // Update virtual selection UI for a hook
        function updateVirtualSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, virtuals: [], all_virtuals: true };
            }

            const allVirtualsChecked = hookConfig.all_virtuals === true;
            const selectedVirtuals = hookConfig.virtuals || [];
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            const allVirtualsCheckbox = document.getElementById(`${hookType}-all-virtuals`);

            // Update "All Virtuals" checkbox
            allVirtualsCheckbox.checked = allVirtualsChecked;

            // Show/hide virtuals list based on "All Virtuals" selection
            if (allVirtualsChecked) {
                listEl.style.display = 'none';
            } else {
                listEl.style.display = 'block';
                buildVirtualsList(hookType, selectedVirtuals);
            }
        }

        // Update scene selection UI for a hook
        function updateSceneSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { scenes: [] };
            }

            const selectedScenes = hookConfig.scenes || [];
            buildScenesList(hookType, selectedScenes);
        }

        // Build scenes list HTML
        function buildScenesList(hookType, selectedScenes) {
            const listEl = document.getElementById(`${hookType}-scenes-list`);
            listEl.innerHTML = '';

            if (availableScenes.length === 0) {
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888';
                listEl.innerHTML = `<p class="no-virtuals">No scenes available. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create scenes first, then refresh this page.</p>`;
                return;
            }

            availableScenes.forEach(sid => {
                const sceneDiv = document.createElement('div');
                sceneDiv.className = 'scene-item';
                sceneDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="scene-checkbox" data-sid="${escapeHtml(sid)}" data-hook="${hookType}" ${selectedScenes.includes(sid) ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(sid)}</span>
                    </label>
                `;
                listEl.appendChild(sceneDiv);
            });
        }

        // Build virtuals list HTML
        function buildVirtualsList(hookType, selectedVirtuals) {
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            listEl.innerHTML = '';

            if (availableVirtuals.length === 0) {
                // Get LedFX URL from window location (same host, different port)
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888';
                listEl.innerHTML = `<p class="no-virtuals">No virtuals available. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create virtuals first, then refresh this page.</p>`;
                return;
            }

            availableVirtuals.forEach(vid => {
                const virtualConfig = selectedVirtuals.find(v => v.id === vid) || { id: vid, repeats: 1 };
                
                const virtualDiv = document.createElement('div');
                virtualDiv.className = 'virtual-item';
                virtualDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="virtual-checkbox" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" ${selectedVirtuals.some(v => v.id === vid) ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(vid)}</span>
                    </label>
                    <div class="virtual-repeats">
                        <div class="repeat-group">
                            <label>Repeats:</label>
                            <input type="number" class="repeat-input" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" value="${virtualConfig.repeats || 1}" min="0" max="10">
                        </div>
                    </div>
                `;
                listEl.appendChild(virtualDiv);
            });
        }

        // Handle hook enable/disable toggle changes
        document.getElementById('start-hook-enabled').addEventListener('change', function() {
            const configSection = document.getElementById('start-hook-config');
            configSection.style.display = this.checked ? 'block' : 'none';
            if (this.checked && configData) {
                updateHookConfig('start', configData.virtuals.hooks?.start);
            }
        });

        document.getElementById('end-hook-enabled').addEventListener('change', function() {
            const configSection = document.getElementById('end-hook-config');
            configSection.style.display = this.checked ? 'block' : 'none';
            if (this.checked && configData) {
                updateHookConfig('end', configData.virtuals.hooks?.end);
            }
        });

        // Handle mode tab switching
        document.querySelectorAll('.mode-tab').forEach(tab => {
            tab.addEventListener('click', function() {
                const hookType = this.dataset.hook;
                const mode = this.dataset.mode;
                
                // Update active tab
                document.querySelectorAll(`.mode-tab[data-hook="${hookType}"]`).forEach(t => t.classList.remove('active'));
                this.classList.add('active');
                
                // Show/hide mode content
                const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
                const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
                toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
                sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';
                
                // Hide/show "All Virtuals" checkbox based on mode
                const allVirtualsLabel = document.querySelector(`#${hookType}-all-virtuals`).closest('.all-virtuals-label');
                if (allVirtualsLabel) {
                    allVirtualsLabel.style.display = mode === 'toggle' ? 'flex' : 'none';
                }
                
                markFormChanged();
            });
        });

        // Handle "All Virtuals" checkbox changes
        document.getElementById('start-all-virtuals').addEventListener('change', function() {
            const listEl = document.getElementById('start-virtuals-list');
            if (this.checked) {
                listEl.style.display = 'none';
            } else {
                listEl.style.display = 'block';
                if (listEl.innerHTML.includes('Loading')) {
                    // Build list if not already built
                    const hookConfig = configData?.virtuals?.hooks?.start || { virtuals: [], all_virtuals: false };
                    buildVirtualsList('start', hookConfig.virtuals);
                }
            }
            markFormChanged();
        });

        document.getElementById('end-all-virtuals').addEventListener('change', function() {
            const listEl = document.getElementById('end-virtuals-list');
            if (this.checked) {
                listEl.style.display = 'none';
            } else {
                listEl.style.display = 'block';
                if (listEl.innerHTML.includes('Loading')) {
                    // Build list if not already built
                    const hookConfig = configData?.virtuals?.hooks?.end || { virtuals: [], all_virtuals: false };
                    buildVirtualsList('end', hookConfig.virtuals);
                }
            }
            markFormChanged();
        });

        // Get current form state for comparison
        function getFormState() {
            const state = {
                startEnabled: document.getElementById('start-hook-enabled').checked,
                endEnabled: document.getElementById('end-hook-enabled').checked,
                startMode: document.querySelector('.mode-tab[data-hook="start"].active')?.dataset.mode || 'toggle',
                endMode: document.querySelector('.mode-tab[data-hook="end"].active')?.dataset.mode || 'toggle',
                startAllVirtuals: document.getElementById('start-all-virtuals').checked,
                endAllVirtuals: document.getElementById('end-all-virtuals').checked,
                startVirtuals: [],
                endVirtuals: [],
                startScenes: [],
                endScenes: []
            };

            // Collect virtual selections
            document.querySelectorAll('.virtual-checkbox[data-hook="start"]:checked').forEach(cb => {
                const vid = cb.dataset.vid;
                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="start"][data-vid="${vid}"]`)?.value) || 1;
                state.startVirtuals.push({ id: vid, repeats: repeats });
            });
            document.querySelectorAll('.virtual-checkbox[data-hook="end"]:checked').forEach(cb => {
                const vid = cb.dataset.vid;
                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="end"][data-vid="${vid}"]`)?.value) || 0;
                state.endVirtuals.push({ id: vid, repeats: repeats });
            });

            // Collect scene selections
            document.querySelectorAll('.scene-checkbox[data-hook="start"]:checked').forEach(cb => {
                state.startScenes.push(cb.dataset.sid);
            });
            document.querySelectorAll('.scene-checkbox[data-hook="end"]:checked').forEach(cb => {
                state.endScenes.push(cb.dataset.sid);
            });

            return JSON.stringify(state);
        }

        // Check if there are unsaved changes by comparing current state with saved state
        function checkUnsavedChanges() {
            if (!savedFormState) {
                return false;
            }
            const currentState = getFormState();
            return currentState !== savedFormState;
        }

        // Add change listeners to all form inputs
        function addFormChangeListeners() {
            // Listen for changes on checkboxes and inputs
            document.addEventListener('change', function(e) {
                if (e.target.matches('.virtual-checkbox, .scene-checkbox, .repeat-input')) {
                    markFormChanged();
                }
            });

            // Listen for input changes on repeat inputs
            document.addEventListener('input', function(e) {
                if (e.target.matches('.repeat-input')) {
                    markFormChanged();
                }
            });
        }

        // Save configuration
        document.getElementById('config-form').addEventListener('submit', async function(e) {
            e.preventDefault();

            const saveBtn = document.getElementById('save-btn');
            const saveStatus = document.getElementById('save-status');
            
            saveBtn.disabled = true;
            saveStatus.textContent = 'Saving...';

            try {
                // Collect start hook configuration (only if enabled)
                const startEnabled = document.getElementById('start-hook-enabled').checked;
                let startMode = 'toggle';
                let startAllVirtuals = true;
                let startVirtuals = [];
                let startScenes = [];
                if (startEnabled) {
                    // Get active mode
                    const activeStartTab = document.querySelector(`.mode-tab[data-hook="start"].active`);
                    startMode = activeStartTab ? activeStartTab.dataset.mode : 'toggle';
                    
                    if (startMode === 'toggle') {
                        startAllVirtuals = document.getElementById('start-all-virtuals').checked;
                        if (!startAllVirtuals) {
                            document.querySelectorAll('.virtual-checkbox[data-hook="start"]:checked').forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="start"][data-vid="${vid}"]`).value) || 1;
                                if (repeats > 0) {
                                    startVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        // Scene mode
                        document.querySelectorAll('.scene-checkbox[data-hook="start"]:checked').forEach(cb => {
                            startScenes.push(cb.dataset.sid);
                        });
                    }
                }

                // Collect end hook configuration (only if enabled)
                const endEnabled = document.getElementById('end-hook-enabled').checked;
                let endMode = 'toggle';
                let endAllVirtuals = true;
                let endVirtuals = [];
                let endScenes = [];
                if (endEnabled) {
                    // Get active mode
                    const activeEndTab = document.querySelector(`.mode-tab[data-hook="end"].active`);
                    endMode = activeEndTab ? activeEndTab.dataset.mode : 'toggle';
                    
                    if (endMode === 'toggle') {
                        endAllVirtuals = document.getElementById('end-all-virtuals').checked;
                        if (!endAllVirtuals) {
                            document.querySelectorAll('.virtual-checkbox[data-hook="end"]:checked').forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="end"][data-vid="${vid}"]`).value) || 0;
                                if (repeats > 0) {
                                    endVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        // Scene mode
                        document.querySelectorAll('.scene-checkbox[data-hook="end"]:checked').forEach(cb => {
                            endScenes.push(cb.dataset.sid);
                        });
                    }
                }

                const configPayload = {
                    start_enabled: startEnabled,
                    end_enabled: endEnabled,
                    start_hook: {
                        mode: startMode,
                        all_virtuals: startAllVirtuals,
                        virtuals: startVirtuals,
                        scenes: startScenes
                    },
                    end_hook: {
                        mode: endMode,
                        all_virtuals: endAllVirtuals,
                        virtuals: endVirtuals,
                        scenes: endScenes
                    }
                };

                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configPayload)
                });

                const data = await response.json();

                if (!response.ok || data.error) {
                    throw new Error(data.error || `HTTP ${response.status}`);
                }

                if (data.warning) {
                    showSuccess(`Configuration saved with warning: ${data.warning}`);
                } else {
                    showSuccess('Configuration saved successfully!');
                }

                // Reload config to reflect any changes
                await loadConfig();
                
                // Reset unsaved changes flag after successful save
                hasUnsavedChanges = false;
                savedFormState = getFormState();

            } catch (error) {
                showError(`Failed to save configuration: ${error.message}`);
            } finally {
                saveBtn.disabled = false;
                saveStatus.textContent = '';
            }
        });

        // Auto-refresh available virtuals and scenes lists
        async function refreshLists() {
            try {
                const response = await fetch('/api/config');
                if (response.ok) {
                    const data = await response.json();
                    const newVirtuals = data.available_virtuals || [];
                    const newScenes = data.available_scenes || [];
                    
                    // Only update if lists changed
                    if (JSON.stringify(newVirtuals) !== JSON.stringify(availableVirtuals) ||
                        JSON.stringify(newScenes) !== JSON.stringify(availableScenes)) {
                        availableVirtuals = newVirtuals;
                        availableScenes = newScenes;
                        if (configData) {
                            updateHookConfig('start', configData.virtuals.hooks?.start);
                            updateHookConfig('end', configData.virtuals.hooks?.end);
                        }
                    }
                }
            } catch (error) {
                // Silently fail on refresh
            }
        }

        // Warn before leaving with unsaved changes
        window.addEventListener('beforeunload', (e) => {
            if (hasUnsavedChanges || checkUnsavedChanges()) {
                e.preventDefault();
                e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                return e.returnValue;
            }
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });

        // Intercept navigation links to warn about unsaved changes
        document.addEventListener('click', (e) => {
            const link = e.target.closest('a');
            if (link && link.href && !link.target && (hasUnsavedChanges || checkUnsavedChanges())) {
                if (!confirm('You have unsaved changes. Are you sure you want to leave this page?')) {
                    e.preventDefault();
                    return false;
                }
            }
        });

        // Initial load
        loadConfig();

        // Add form change listeners
        addFormChangeListeners();

        // Refresh virtuals and scenes lists every 10 seconds
        refreshInterval = setInterval(refreshLists, 10000);
    </script>
</body>
</html>
