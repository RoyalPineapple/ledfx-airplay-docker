<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AirGlow - AirPlay Configuration</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
</head>
<body>
    <div class="banner-container">
        <img src="https://raw.githubusercontent.com/RoyalPineapple/airglow/master/web/static/banner.jpg" alt="Aurora Borealis" class="banner-image" onerror="this.parentElement.style.display='none'">
        <div class="banner-overlay">
            <h1 class="banner-title">AirGlow</h1>
            <p class="banner-tagline">AirPlay Configuration</p>
        </div>
    </div>
    <div class="container">
        <header>
            <nav>
                <a href="/">Home</a>
                <a href="/status">Status Dashboard</a>
            </nav>
        </header>

        <div id="error-message" class="error-message" style="display: none;"></div>
        <div id="success-message" class="success-message" style="display: none;"></div>

        <form id="config-form">
            <!-- When AirPlay Connects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Connects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="start-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay connects</p>
                
                <div id="start-hook-config" class="hook-config-section" style="display: none;">
                    <!-- Mode Tabs -->
                    <div class="mode-tabs">
                        <button type="button" class="mode-tab active" data-hook="start" data-mode="toggle">Toggle On</button>
                        <button type="button" class="mode-tab" data-hook="start" data-mode="scene">Scene</button>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="start-toggle-mode" class="mode-content">
                        <div class="virtual-selection-controls" id="start-virtual-selection-controls" style="display: none;">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="start-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">All Virtuals</span>
                            </label>
                        </div>

                        <div id="start-virtuals-list" class="virtuals-list">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="start-scene-mode" class="mode-content" style="display: none;">
                        <div id="start-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </div>
            </section>

            <!-- When AirPlay Disconnects Section -->
            <section class="config-section">
                <div class="hook-header">
                    <h2>When AirPlay Disconnects</h2>
                    <label class="toggle-label">
                        <input type="checkbox" id="end-hook-enabled" class="toggle-checkbox">
                        <span class="toggle-switch"></span>
                        <span class="toggle-text">Enabled</span>
                    </label>
                </div>
                <p class="section-description">Configure behavior when AirPlay disconnects</p>
                
                <div id="end-hook-config" class="hook-config-section" style="display: none;">
                    <!-- Mode Tabs -->
                    <div class="mode-tabs">
                        <button type="button" class="mode-tab active" data-hook="end" data-mode="toggle">Toggle Off</button>
                        <button type="button" class="mode-tab" data-hook="end" data-mode="scene">Scene</button>
                    </div>

                    <!-- Toggle Mode Content -->
                    <div id="end-toggle-mode" class="mode-content">
                        <div class="virtual-selection-controls" id="end-virtual-selection-controls" style="display: none;">
                            <label class="checkbox-label all-virtuals-label">
                                <input type="checkbox" id="end-all-virtuals" class="checkbox-input all-virtuals-checkbox">
                                <span class="checkbox-text">All Virtuals</span>
                            </label>
                        </div>

                        <div id="end-virtuals-list" class="virtuals-list">
                            <p class="loading">Loading virtuals...</p>
                        </div>
                    </div>

                    <!-- Scene Mode Content -->
                    <div id="end-scene-mode" class="mode-content" style="display: none;">
                        <div id="end-scenes-list" class="scenes-list">
                            <p class="loading">Loading scenes...</p>
                        </div>
                    </div>
                </div>
            </section>

        </form>
    </div>

    <script>
        let configData = null;
        let availableVirtuals = [];
        let availableScenes = [];
        let hasDevices = false;
        let refreshInterval = null;
        // Track previous state of each control for rollback on failure
        let controlStates = new Map();
        let saveInProgress = false;

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Show error message
        function showError(message) {
            const errorEl = document.getElementById('error-message');
            errorEl.textContent = message;
            errorEl.style.display = 'block';
            setTimeout(() => {
                errorEl.style.display = 'none';
            }, 5000);
        }

        // Show success message
        function showSuccess(message) {
            const successEl = document.getElementById('success-message');
            successEl.textContent = message;
            successEl.style.display = 'block';
            setTimeout(() => {
                successEl.style.display = 'none';
            }, 3000);
        }

        // Load configuration
        async function loadConfig() {
            try {
                const response = await fetch('/api/config');
                if (!response.ok) {
                    throw new Error(`HTTP ${response.status}`);
                }
                const data = await response.json();
                
                if (data.error) {
                    showError(data.error);
                    return;
                }

                configData = data;
                availableVirtuals = data.available_virtuals || [];
                availableScenes = data.available_scenes || [];
                hasDevices = data.has_devices !== false;

                // Update hook toggles
                const startEnabled = data.hooks.start_hook_enabled !== false;
                const endEnabled = data.hooks.end_hook_enabled !== false;
                
                document.getElementById('start-hook-enabled').checked = startEnabled;
                document.getElementById('end-hook-enabled').checked = endEnabled;

                // Show/hide hook configuration sections based on enabled state
                document.getElementById('start-hook-config').style.display = startEnabled ? 'block' : 'none';
                document.getElementById('end-hook-config').style.display = endEnabled ? 'block' : 'none';

                // Update configuration for each hook (only if enabled)
                if (startEnabled) {
                    updateHookConfig('start', data.virtuals.hooks?.start);
                }
                if (endEnabled) {
                    updateHookConfig('end', data.virtuals.hooks?.end);
                }

                // Store initial state of all controls for rollback
                storeControlStates();

            } catch (error) {
                showError(`Failed to load configuration: ${error.message}`);
            }
        }

        // Update hook configuration UI (mode, virtuals, scenes)
        function updateHookConfig(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, mode: 'toggle', virtuals: [], all_virtuals: true, scenes: [] };
            }

            const mode = hookConfig.mode || 'toggle';
            
            // Update mode tabs
            document.querySelectorAll(`.mode-tab[data-hook="${hookType}"]`).forEach(tab => {
                if (tab.dataset.mode === mode) {
                    tab.classList.add('active');
                } else {
                    tab.classList.remove('active');
                }
            });

            // Show/hide mode content
            const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
            const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
            toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
            sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';

            // Hide "All Virtuals" checkbox when mode is scene
            const allVirtualsLabel = document.querySelector(`#${hookType}-all-virtuals`).closest('.all-virtuals-label');
            if (allVirtualsLabel) {
                allVirtualsLabel.style.display = mode === 'toggle' ? 'flex' : 'none';
            }

            if (mode === 'toggle') {
                updateVirtualSelection(hookType, hookConfig);
            } else {
                updateSceneSelection(hookType, hookConfig);
            }
        }

        // Update virtual selection UI for a hook
        function updateVirtualSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { enabled: true, virtuals: [], all_virtuals: true };
            }

            const allVirtualsChecked = hookConfig.all_virtuals === true;
            const selectedVirtuals = hookConfig.virtuals || [];
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            const allVirtualsCheckbox = document.getElementById(`${hookType}-all-virtuals`);

            // Update "All Virtuals" checkbox
            allVirtualsCheckbox.checked = allVirtualsChecked;

            // Hide entire virtual selection controls section if no virtuals are available OR no devices are configured
            const virtualSelectionControls = document.getElementById(`${hookType}-virtual-selection-controls`);
            if (virtualSelectionControls) {
                const shouldShow = hasDevices && availableVirtuals.length > 0;
                virtualSelectionControls.style.display = shouldShow ? 'block' : 'none';
            }
            
            // If no virtuals or no devices, force all_virtuals to false
            if ((!hasDevices || availableVirtuals.length === 0) && allVirtualsChecked) {
                allVirtualsCheckbox.checked = false;
                hookConfig.all_virtuals = false;
            }
            
            // Always show the virtuals list area and build it to show proper messages
            listEl.style.display = 'block';
            
            // Show/hide virtuals list content based on "All Virtuals" selection
            if (allVirtualsChecked && hasDevices && availableVirtuals.length > 0) {
                // Hide the list content when "All Virtuals" is checked
                listEl.innerHTML = '';
            } else {
                // Always build the list to show proper messages (no devices, no virtuals, or virtual list)
                buildVirtualsList(hookType, selectedVirtuals);
            }
        }

        // Update scene selection UI for a hook
        function updateSceneSelection(hookType, hookConfig) {
            if (!hookConfig) {
                hookConfig = { scenes: [] };
            }

            const selectedScenes = hookConfig.scenes || [];
            buildScenesList(hookType, selectedScenes);
        }

        // Build scenes list HTML
        function buildScenesList(hookType, selectedScenes) {
            const listEl = document.getElementById(`${hookType}-scenes-list`);
            listEl.innerHTML = '';

            if (availableScenes.length === 0) {
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Scenes';
                listEl.innerHTML = `<p class="no-virtuals">No scenes available. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create scenes first, then refresh this page.</p>`;
                return;
            }

            availableScenes.forEach(sid => {
                const sceneDiv = document.createElement('div');
                sceneDiv.className = 'scene-item';
                sceneDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="scene-checkbox" data-sid="${escapeHtml(sid)}" data-hook="${hookType}" ${selectedScenes.includes(sid) ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(sid)}</span>
                    </label>
                `;
                listEl.appendChild(sceneDiv);
            });
        }

        // Build virtuals list HTML
        function buildVirtualsList(hookType, selectedVirtuals) {
            const listEl = document.getElementById(`${hookType}-virtuals-list`);
            listEl.innerHTML = '';

            // Check for devices first (primary check)
            if (!hasDevices) {
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Devices';
                listEl.innerHTML = `<p class="no-virtuals">No LedFX devices configured. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to add devices first, then refresh this page.</p>`;
                return;
            }

            if (availableVirtuals.length === 0) {
                // Get LedFX URL from window location (same host, different port)
                const ledfxUrl = window.location.protocol + '//' + window.location.hostname + ':8888/#/Virtuals';
                listEl.innerHTML = `<p class="no-virtuals">No virtuals available. <a href="${ledfxUrl}" target="_blank">Open LedFX</a> to create virtuals first, then refresh this page.</p>`;
                return;
            }

            availableVirtuals.forEach(vid => {
                const virtualConfig = selectedVirtuals.find(v => v.id === vid) || { id: vid, repeats: 1 };
                
                const virtualDiv = document.createElement('div');
                virtualDiv.className = 'virtual-item';
                virtualDiv.innerHTML = `
                    <label class="checkbox-label">
                        <input type="checkbox" class="virtual-checkbox" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" ${selectedVirtuals.some(v => v.id === vid) ? 'checked' : ''}>
                        <span class="checkbox-text">${escapeHtml(vid)}</span>
                    </label>
                    <div class="virtual-repeats">
                        <div class="repeat-group">
                            <label>Repeats:</label>
                            <input type="number" class="repeat-input" data-vid="${escapeHtml(vid)}" data-hook="${hookType}" value="${virtualConfig.repeats || 1}" min="0" max="10">
                        </div>
                    </div>
                `;
                listEl.appendChild(virtualDiv);
            });
        }


        // Store the current state of all controls for rollback
        function storeControlStates() {
            controlStates.clear();
            
            // Store hook toggles
            controlStates.set('start-hook-enabled', document.getElementById('start-hook-enabled').checked);
            controlStates.set('end-hook-enabled', document.getElementById('end-hook-enabled').checked);
            
            // Store mode tabs
            const startModeTab = document.querySelector('.mode-tab[data-hook="start"].active');
            const endModeTab = document.querySelector('.mode-tab[data-hook="end"].active');
            controlStates.set('start-mode', startModeTab ? startModeTab.dataset.mode : 'toggle');
            controlStates.set('end-mode', endModeTab ? endModeTab.dataset.mode : 'toggle');
            
            // Store all virtuals checkboxes
            controlStates.set('start-all-virtuals', document.getElementById('start-all-virtuals').checked);
            controlStates.set('end-all-virtuals', document.getElementById('end-all-virtuals').checked);
            
            // Store virtual checkboxes
            document.querySelectorAll('.virtual-checkbox').forEach(cb => {
                controlStates.set(cb.id || `virtual-${cb.dataset.hook}-${cb.dataset.vid}`, cb.checked);
            });
            
            // Store scene checkboxes
            document.querySelectorAll('.scene-checkbox').forEach(cb => {
                controlStates.set(cb.id || `scene-${cb.dataset.hook}-${cb.dataset.sid}`, cb.checked);
            });
            
            // Store repeat inputs
            document.querySelectorAll('.repeat-input').forEach(input => {
                controlStates.set(input.id || `repeat-${input.dataset.hook}-${input.dataset.vid}`, input.value);
            });
        }
        
        // Revert a specific control to its previous state
        function revertControl(controlId, previousValue) {
            const element = document.getElementById(controlId);
            if (!element) {
                // Try to find by data attributes
                const [type, hook, id] = controlId.split('-');
                if (type === 'virtual') {
                    const cb = document.querySelector(`.virtual-checkbox[data-hook="${hook}"][data-vid="${id}"]`);
                    if (cb) cb.checked = previousValue;
                } else if (type === 'scene') {
                    const cb = document.querySelector(`.scene-checkbox[data-hook="${hook}"][data-sid="${id}"]`);
                    if (cb) cb.checked = previousValue;
                } else if (type === 'repeat') {
                    const input = document.querySelector(`.repeat-input[data-hook="${hook}"][data-vid="${id}"]`);
                    if (input) input.value = previousValue;
                }
                return;
            }
            
            if (element.type === 'checkbox') {
                element.checked = previousValue;
            } else if (element.type === 'number' || element.type === 'text') {
                element.value = previousValue;
            }
        }
        
        // Auto-save configuration on change
        async function autoSave(controlId, previousValue) {
            if (saveInProgress) {
                // If a save is already in progress, queue this one
                setTimeout(() => autoSave(controlId, previousValue), 100);
                return;
            }
            
            saveInProgress = true;
            
            try {
                // Collect current configuration
                const startEnabled = document.getElementById('start-hook-enabled').checked;
                let startMode = 'toggle';
                let startAllVirtuals = true;
                let startVirtuals = [];
                let startScenes = [];
                if (startEnabled) {
                    const activeStartTab = document.querySelector(`.mode-tab[data-hook="start"].active`);
                    startMode = activeStartTab ? activeStartTab.dataset.mode : 'toggle';
                    
                    if (startMode === 'toggle') {
                        // Only check "All Virtuals" if devices and virtuals exist
                        if (hasDevices && availableVirtuals.length > 0) {
                            startAllVirtuals = document.getElementById('start-all-virtuals').checked;
                        } else {
                            startAllVirtuals = false; // Can't use all virtuals if no devices or no virtuals available
                        }
                        if (!startAllVirtuals) {
                            document.querySelectorAll('.virtual-checkbox[data-hook="start"]:checked').forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="start"][data-vid="${vid}"]`)?.value) || 1;
                                if (repeats > 0) {
                                    startVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.scene-checkbox[data-hook="start"]:checked').forEach(cb => {
                            startScenes.push(cb.dataset.sid);
                        });
                    }
                }

                const endEnabled = document.getElementById('end-hook-enabled').checked;
                let endMode = 'toggle';
                let endAllVirtuals = true;
                let endVirtuals = [];
                let endScenes = [];
                if (endEnabled) {
                    const activeEndTab = document.querySelector(`.mode-tab[data-hook="end"].active`);
                    endMode = activeEndTab ? activeEndTab.dataset.mode : 'toggle';
                    
                    if (endMode === 'toggle') {
                        // Only check "All Virtuals" if devices and virtuals exist
                        if (hasDevices && availableVirtuals.length > 0) {
                            endAllVirtuals = document.getElementById('end-all-virtuals').checked;
                        } else {
                            endAllVirtuals = false; // Can't use all virtuals if no devices or no virtuals available
                        }
                        if (!endAllVirtuals) {
                            document.querySelectorAll('.virtual-checkbox[data-hook="end"]:checked').forEach(cb => {
                                const vid = cb.dataset.vid;
                                const repeats = parseInt(document.querySelector(`.repeat-input[data-hook="end"][data-vid="${vid}"]`)?.value) || 0;
                                if (repeats > 0) {
                                    endVirtuals.push({ id: vid, repeats: repeats });
                                }
                            });
                        }
                    } else {
                        document.querySelectorAll('.scene-checkbox[data-hook="end"]:checked').forEach(cb => {
                            endScenes.push(cb.dataset.sid);
                        });
                    }
                }

                const configPayload = {
                    start_enabled: startEnabled,
                    end_enabled: endEnabled,
                    start_hook: {
                        mode: startMode,
                        all_virtuals: startAllVirtuals,
                        virtuals: startVirtuals,
                        scenes: startScenes
                    },
                    end_hook: {
                        mode: endMode,
                        all_virtuals: endAllVirtuals,
                        virtuals: endVirtuals,
                        scenes: endScenes
                    }
                };

                const response = await fetch('/api/config', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(configPayload)
                });

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Failed to save configuration' }));
                    throw new Error(errorData.error || 'Failed to save configuration');
                }

                const data = await response.json();
                
                // Update stored states on success
                storeControlStates();
                
                // Show brief success indicator
                showControlFeedback(controlId, true);
                
            } catch (error) {
                // Revert the control that failed
                revertControl(controlId, previousValue);
                showControlFeedback(controlId, false, error.message);
            } finally {
                saveInProgress = false;
            }
        }
        
        // Show feedback for a specific control
        function showControlFeedback(controlId, success, errorMessage = null) {
            const element = document.getElementById(controlId);
            if (!element) return;
            
            // Remove existing feedback
            const existingFeedback = element.parentElement.querySelector('.control-feedback');
            if (existingFeedback) {
                existingFeedback.remove();
            }
            
            if (success) {
                const feedback = document.createElement('span');
                feedback.className = 'control-feedback success';
                feedback.textContent = '✓';
                feedback.title = 'Saved';
                element.parentElement.style.position = 'relative';
                element.parentElement.appendChild(feedback);
                setTimeout(() => feedback.remove(), 2000);
            } else {
                const feedback = document.createElement('span');
                feedback.className = 'control-feedback error';
                feedback.textContent = '✗';
                feedback.title = errorMessage || 'Failed to save';
                element.parentElement.style.position = 'relative';
                element.parentElement.appendChild(feedback);
                setTimeout(() => feedback.remove(), 3000);
            }
        }

        // Add change listeners to all form inputs with auto-save
        function addFormChangeListeners() {
            // Hook enable/disable toggles
            document.getElementById('start-hook-enabled').addEventListener('change', function() {
                const previousValue = controlStates.get('start-hook-enabled') || false;
                controlStates.set('start-hook-enabled', this.checked);
                const configSection = document.getElementById('start-hook-config');
                configSection.style.display = this.checked ? 'block' : 'none';
                if (this.checked && configData) {
                    updateHookConfig('start', configData.virtuals.hooks?.start);
                }
                autoSave('start-hook-enabled', previousValue);
            });

            document.getElementById('end-hook-enabled').addEventListener('change', function() {
                const previousValue = controlStates.get('end-hook-enabled') || false;
                controlStates.set('end-hook-enabled', this.checked);
                const configSection = document.getElementById('end-hook-config');
                configSection.style.display = this.checked ? 'block' : 'none';
                if (this.checked && configData) {
                    updateHookConfig('end', configData.virtuals.hooks?.end);
                }
                autoSave('end-hook-enabled', previousValue);
            });
            
            // Mode tabs
            document.querySelectorAll('.mode-tab').forEach(tab => {
                tab.addEventListener('click', function() {
                    const hookType = this.dataset.hook;
                    const mode = this.dataset.mode;
                    const previousMode = controlStates.get(`${hookType}-mode`) || 'toggle';
                    
                    // Update active tab
                    document.querySelectorAll(`.mode-tab[data-hook="${hookType}"]`).forEach(t => t.classList.remove('active'));
                    this.classList.add('active');
                    
                    // Show/hide mode content
                    const toggleModeEl = document.getElementById(`${hookType}-toggle-mode`);
                    const sceneModeEl = document.getElementById(`${hookType}-scene-mode`);
                    toggleModeEl.style.display = mode === 'toggle' ? 'block' : 'none';
                    sceneModeEl.style.display = mode === 'scene' ? 'block' : 'none';
                    
                    // Hide/show virtual selection controls based on mode AND device/virtual availability
                    const virtualSelectionControls = document.getElementById(`${hookType}-virtual-selection-controls`);
                    if (virtualSelectionControls) {
                        // Only show if toggle mode AND devices exist AND virtuals exist
                        const shouldShow = mode === 'toggle' && hasDevices && availableVirtuals.length > 0;
                        virtualSelectionControls.style.display = shouldShow ? 'block' : 'none';
                    }
                    
                    // If switching to toggle mode, update virtual selection to show proper messages
                    if (mode === 'toggle') {
                        const hookConfig = configData?.virtuals?.hooks?.[hookType] || { virtuals: [], all_virtuals: false };
                        updateVirtualSelection(hookType, hookConfig);
                    }
                    
                    // Build scenes list if switching to scene mode and list hasn't been built yet
                    if (mode === 'scene') {
                        const scenesListEl = document.getElementById(`${hookType}-scenes-list`);
                        if (scenesListEl.innerHTML.includes('Loading')) {
                            const hookConfig = configData?.virtuals?.hooks?.[hookType] || { scenes: [] };
                            updateSceneSelection(hookType, hookConfig);
                        }
                    }
                    
                    controlStates.set(`${hookType}-mode`, mode);
                    autoSave(`${hookType}-mode`, previousMode);
                });
            });
            
            // All virtuals checkboxes
            document.getElementById('start-all-virtuals').addEventListener('change', function() {
                const previousValue = controlStates.get('start-all-virtuals') || false;
                controlStates.set('start-all-virtuals', this.checked);
                const listEl = document.getElementById('start-virtuals-list');
                if (this.checked) {
                    listEl.style.display = 'none';
                } else {
                    listEl.style.display = 'block';
                    if (listEl.innerHTML.includes('Loading')) {
                        const hookConfig = configData?.virtuals?.hooks?.start || { virtuals: [], all_virtuals: false };
                        buildVirtualsList('start', hookConfig.virtuals);
                    }
                }
                autoSave('start-all-virtuals', previousValue);
            });

            document.getElementById('end-all-virtuals').addEventListener('change', function() {
                const previousValue = controlStates.get('end-all-virtuals') || false;
                controlStates.set('end-all-virtuals', this.checked);
                const listEl = document.getElementById('end-virtuals-list');
                if (this.checked) {
                    listEl.style.display = 'none';
                } else {
                    listEl.style.display = 'block';
                    if (listEl.innerHTML.includes('Loading')) {
                        const hookConfig = configData?.virtuals?.hooks?.end || { virtuals: [], all_virtuals: false };
                        buildVirtualsList('end', hookConfig.virtuals);
                    }
                }
                autoSave('end-all-virtuals', previousValue);
            });
            
            // Listen for changes on checkboxes and inputs
            document.addEventListener('change', function(e) {
                if (e.target.matches('.virtual-checkbox, .scene-checkbox')) {
                    const controlId = e.target.id || `${e.target.classList.contains('virtual-checkbox') ? 'virtual' : 'scene'}-${e.target.dataset.hook}-${e.target.dataset.vid || e.target.dataset.sid}`;
                    const previousValue = controlStates.get(controlId) || false;
                    controlStates.set(controlId, e.target.checked);
                    autoSave(controlId, previousValue);
                }
            });

            // Listen for input changes on repeat inputs (with debounce)
            let repeatInputTimeout = null;
            document.addEventListener('input', function(e) {
                if (e.target.matches('.repeat-input')) {
                    const controlId = e.target.id || `repeat-${e.target.dataset.hook}-${e.target.dataset.vid}`;
                    const previousValue = controlStates.get(controlId) || e.target.value;
                    
                    // Debounce repeat input saves (wait 500ms after user stops typing)
                    clearTimeout(repeatInputTimeout);
                    repeatInputTimeout = setTimeout(() => {
                        controlStates.set(controlId, e.target.value);
                        autoSave(controlId, previousValue);
                    }, 500);
                }
            });
        }


        // Auto-refresh available virtuals and scenes lists
        async function refreshLists() {
            try {
                const response = await fetch('/api/config');
                if (response.ok) {
                    const data = await response.json();
                    const newVirtuals = data.available_virtuals || [];
                    const newScenes = data.available_scenes || [];
                    
                    // Only update if lists changed
                    if (JSON.stringify(newVirtuals) !== JSON.stringify(availableVirtuals) ||
                        JSON.stringify(newScenes) !== JSON.stringify(availableScenes)) {
                        availableVirtuals = newVirtuals;
                        availableScenes = newScenes;
                        if (configData) {
                            updateHookConfig('start', configData.virtuals.hooks?.start);
                            updateHookConfig('end', configData.virtuals.hooks?.end);
                        }
                    }
                }
            } catch (error) {
                // Silently fail on refresh
            }
        }

        // Clear refresh interval on page unload
        window.addEventListener('beforeunload', (e) => {
            if (refreshInterval) {
                clearInterval(refreshInterval);
            }
        });

        // Initial load
        loadConfig();

        // Add form change listeners
        addFormChangeListeners();

        // Refresh virtuals and scenes lists every 10 seconds
        refreshInterval = setInterval(refreshLists, 10000);
    </script>
</body>
</html>
